// @ts-nocheck
/* eslint-disable */
/* This file was generated by Unframer for Framer project 0db2cec6a51bfbc8 "AM portfolio", do not edit manually */
"use client";

/**
 * @typedef Locale
 * string
 */

/**
 * @typedef {{
 * children?: React.ReactNode
 * locale?: Locale
 * style?: React.CSSProperties
 * className?: string
 * id?: string
 * ref?: any
 * width?: any
 * height?: any
 * layoutId?: string
 * text?: string // Text
 * speed(ms)?: number // Speed (ms)
 * font?: undefined // Font
 * textColor?: string // Text Color
 * cursorColor?: string // Cursor Color
}} Props

 */
import { routes } from "./chunks/chunk-23HYNGZD.js";

// virtual:pro-text-type
import { Fragment } from "react";
import { ContextProviders } from "unframer";

// /:https://framerusercontent.com/modules/xe0L9BbQqp1vhQ4Bk1tS/KUs0BjDhS5CLbI8g3Qc2/ProTextType.js
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useEffect, useRef, useState, startTransition } from "react";
import {
	addPropertyControls,
	ControlType,
	useIsStaticRenderer,
} from "unframer";
function ProTextType(props) {
	const { text, speed, font, color, cursorColor, style } = props;
	const [displayed, setDisplayed] = useState("");
	const [showCursor, setShowCursor] = useState(true);
	const isStatic = useIsStaticRenderer();
	const intervalRef = useRef(null);
	const cursorIntervalRef = useRef(null);
	useEffect(() => {
		if (isStatic) {
			setDisplayed(text);
			setShowCursor(false);
			return;
		}
		setDisplayed("");
		let i = 0;
		if (intervalRef.current) clearInterval(intervalRef.current);
		intervalRef.current = window.setInterval(() => {
			startTransition(() => {
				setDisplayed((prev) => {
					if (i < text.length) {
						i++;
						return text.slice(0, i);
					} else {
						if (intervalRef.current) clearInterval(intervalRef.current);
						return prev;
					}
				});
			});
		}, speed);
		return () => {
			if (intervalRef.current) clearInterval(intervalRef.current);
		};
	}, [text, speed, isStatic]);
	useEffect(() => {
		if (isStatic) return;
		if (cursorIntervalRef.current) clearInterval(cursorIntervalRef.current);
		cursorIntervalRef.current = window.setInterval(() => {
			startTransition(() => setShowCursor((c) => !c));
		}, 500);
		return () => {
			if (cursorIntervalRef.current) clearInterval(cursorIntervalRef.current);
		};
	}, [isStatic]);
	return (
		<span
			style={{
				...font,
				color,
				...style,
				display: "inline-block",
				minWidth: "max-content",
				position: "relative",
			}}
		>
			{displayed}
			<span
				style={{
					display: showCursor ? "inline-block" : "none",
					width: 2,
					height: "1em",
					background: cursorColor,
					marginLeft: 2,
					verticalAlign: "middle",
					borderRadius: 1,
					animation: isStatic ? "none" : "blink 1s step-end infinite",
				}}
				aria-hidden={"true"}
			>
				{"\xA0"}
			</span>
		</span>
	);
}
addPropertyControls(ProTextType, {
	text: {
		type: ControlType.String,
		title: "Text",
		defaultValue: "Type something\u2026",
	},
	speed: {
		type: ControlType.Number,
		title: "Speed (ms)",
		defaultValue: 60,
		min: 10,
		max: 500,
		step: 1,
		unit: "ms",
	},
	font: {
		type: ControlType.Font,
		title: "Font",
		controls: "extended",
		defaultFontType: "sans-serif",
		defaultValue: {
			fontSize: "40px",
			variant: "Bold",
			letterSpacing: "-0.04em",
			lineHeight: "1em",
		},
	},
	color: {
		type: ControlType.Color,
		title: "Text Color",
		defaultValue: "#000000",
	},
	cursorColor: {
		type: ControlType.Color,
		title: "Cursor Color",
		defaultValue: "#000000",
	},
});

// virtual:pro-text-type
import { WithFramerBreakpoints } from "unframer";
import { jsx } from "react/jsx-runtime";
var locales = [];
var defaultResponsiveVariants = {};
/** @type {function(Props): any} */
function ComponentWithRoot({ locale, ...rest }) {
	return (
		<ContextProviders
			routes={routes}
			framerSiteId={
				"0db2cec6a51bfbc819a58c52eb8c1d5df9643fd4922504e375a2cbd7f2ff2fa5"
			}
			locale={locale}
			locales={locales}
		>
			<ProTextType {...rest} />
		</ContextProviders>
	);
}
/**
 * @type {import("unframer").UnframerBreakpoint}
 * Represents a responsive breakpoint for unframer.
 */

/**
 * @typedef VariantsMap
 * Partial record of UnframerBreakpoint to Props.variant, with a mandatory 'base' key.
 * { [key in UnframerBreakpoint]?: Props['variant'] } & { base: Props['variant'] }
 */

/**
 * Renders ProTextTypeFramerComponent for all breakpoints with a variants map. Variant prop is inferred per breakpoint.
 * @function
 * @param {Omit<Props, 'variant'> & {variants?: VariantsMap}} props
 * @returns {any}
 */
ComponentWithRoot.Responsive = ({ locale = "", ...rest }) => {
	return (
		<ContextProviders
			routes={routes}
			framerSiteId={
				"0db2cec6a51bfbc819a58c52eb8c1d5df9643fd4922504e375a2cbd7f2ff2fa5"
			}
			locale={locale}
			locales={locales}
		>
			<WithFramerBreakpoints
				Component={ProTextType}
				variants={defaultResponsiveVariants}
				{...rest}
			/>
		</ContextProviders>
	);
};
Object.assign(ComponentWithRoot, ProTextType);
var pro_text_type_default = ComponentWithRoot;
export { pro_text_type_default as default };
